<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Java序列化"/>




  <meta name="keywords" content="java," />





  <link rel="alternative" href="/atom.xml" title="Xiaoyu Xue's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://fredxue.github.io/2016/08/08/java-ser/"/>


<meta name="description" content="JAVA默认序列化机制和其他序列化框架的特性分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Java序列化">
<meta property="og:url" content="http://fredxue.github.io/2016/08/08/java-ser/index.html">
<meta property="og:site_name" content="Xiaoyu Xue's Blog">
<meta property="og:description" content="JAVA默认序列化机制和其他序列化框架的特性分析">
<meta property="og:updated_time" content="2016-08-08T08:37:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java序列化">
<meta name="twitter:description" content="JAVA默认序列化机制和其他序列化框架的特性分析">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Java序列化 - Xiaoyu Xue's Blog </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Xiaoyu Xue's Blog</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Java序列化
        
      </h1>

      <time class="post-time">
          Aug 8 2016
      </time>
    </header>



    
            <div class="post-content">
            <p><blockquote class="blockquote-center">JAVA默认序列化机制和其他序列化框架的特性分析</blockquote><br><a id="more"></a></p>
<h3 id="What-is-object-serializatoin"><a href="#What-is-object-serializatoin" class="headerlink" title="What is object serializatoin"></a>What is object serializatoin</h3><p>Object serialization is the process of saving an object’s state to a sequence of bytes, as well as the process of rebuilding those bytes into a live object at some future time.</p>
<h3 id="Why-we-need-serialization"><a href="#Why-we-need-serialization" class="headerlink" title="Why we need serialization"></a>Why we need serialization</h3><p>不同的JVM之间需要通信，尤其是在分布式应用中，而存活在JVM（内存）中的对象是无法在不同机器之间传输的，因此需要一种方法将内存中的对象转化成二进制字节流用来持久化或传输。</p>
<hr>
<p>对象序列化除了JDK的序列化方法，还有其他一些第三方序列化框架。</p>
<h2 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h2><h3 id="How-to："><a href="#How-to：" class="headerlink" title="How to："></a>How to：</h3><ol>
<li><p>实现java.io.serializable接口，这个接口知识一个标志性接口，并没有声明任何方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;&#10;&#10;class TestSerial implements Serializable &#123;&#10;&#9;public byte version = 100;&#10;&#9;public byte count = 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Calling  writeObject()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) throws IOException &#123;&#10;&#9;FileOutputStream fos = new FileOutputStream(&#34;temp.out&#34;);&#10;&#9;ObjectOutputStream oos = new ObjectOutputStream(fos);&#10;&#9;TestSerial ts = new TestSerial();&#10;&#9;oos.writeObject(ts);&#10;&#9;oos.flush();&#10;&#9;oos.close();&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Here writeObject() method actually kicks off the serialize algorithm.</p>
<ol>
<li>Deserializaiton<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) throws IOException &#123;&#10;&#9;FileInputStream fis = new FileInputStream(&#34;temp.out&#34;);&#10;&#9;ObjectInputStream oin = new ObjectInputStream(fis);&#10;&#9;TestSerial ts = (TestSerial) oin.readObject();&#10;&#9;System.out.println(&#34;version=&#34;+ts.version);&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里 对象的恢复发生在 oin.readObject()这个方法被调用的时候。 这个方法从二进制字节流中将整个原始的对象图恢复出一个副本出来。</p>
<h3 id="Rule："><a href="#Rule：" class="headerlink" title="Rule："></a>Rule：</h3><p>Rule #1: The object to be persisted must implement the Serializable interface or inherit that implementation from its object hierarchy.</p>
<p>Rule #2: The object to be persisted must mark all nonserializable fields transient</p>
<ul>
<li>没有实现序列化接口的类： java.lang.Object    一些系统级的类Thread，OutputStream and Socket </li>
<li>a constructor is called only when a new instance is created.</li>
<li>static 和 transient 字段被忽略</li>
<li>推荐显示声明一个private的serialVersionID， 因为不显式声明JVM会根据类的情况缺省生成一个ID，而这是类细节敏感的，会容易造成莫名的 InvalidClassExceptions。 为什么要是private关键字？：apply only to the immediately declaring class。 对继承的对象无效。</li>
<li>Customise serialise and deserialise process with overriding two private method  </li>
</ul>
<h3 id="Features-amp-Details"><a href="#Features-amp-Details" class="headerlink" title="Features &amp; Details:"></a>Features &amp; Details:</h3><ul>
<li>首先写出对象的元数据</li>
<li>递归的写出对象的父类信息直到java.lang.object，因为Object没有实现序列化接口</li>
<li>一旦完成了元数据的写出，它会开始写对象真正的数据。</li>
<li>递归地从最高的父类开始写对象的数据直到最后的子类。</li>
</ul>
<p>因此对象序列化后在字节流中的信息包括序列化协议信息，流版本，是否为新对象，是否为新类，类名，SerialVersionID，对象的各个字段（如果字段是引用的另外一个对象contain，会写一个规定的JVM签名），父类信息（同上），contain对象的序列化信息。</p>
<p>JAVA默认在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。</p>
<p>可以看出JDK默认的序列化转化的信息较全，因此空间和时间开销是巨大的。</p>
<h2 id="其他JAVA序列化框架"><a href="#其他JAVA序列化框架" class="headerlink" title="其他JAVA序列化框架"></a>其他JAVA序列化框架</h2><ul>
<li><strong>json</strong></li>
</ul>
<p>json的序列化框架有fastjson,jackson,gson等。冗长且没有IDL；适用于数据量小，实时性较低（例如秒级别）的服务； Web应用前后端的数据交换；JSON格式具有非常强的前后兼容性，并且调式方便，所以对客户端与服务端的通讯尤其适用。</p>
<ul>
<li><strong>xml</strong></li>
</ul>
<p>xml的序列化框架有XStream。XML的序列化和反序列化的空间和时间开销都比较大，对于对性能要求在ms级别的服务，不推荐使用。</p>
<ul>
<li><strong>hessian</strong></li>
</ul>
<p>hessian主要用于java序列化。它的实现机制是着重于数据，附带简单的类型信息的方法：</p>
<ol>
<li><p>对于简单的数据类型。就像Integer a = 1，hessian会序列化成I 1这样的流，I表示int or Integer，1就是数据内容。</p>
</li>
<li><p>对于复杂对象，通过Java的反射机制，hessian把对象所有的属性当成一个Map来序列化，产生类似M className propertyName1 I 1 propertyName S stringValue</p>
</li>
<li><p>对于引用对象，在序列化过程中，如果一个对象之前出现过，hessian会直接插入一个R index这样的块来表示一个引用位置，从而省去再次序列化和反序列化的时间。</p>
</li>
</ol>
<ul>
<li><strong>Thift</strong></li>
</ul>
<p>Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架。<br>相对于JSON和XML而言，Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）。</p>
<ul>
<li><strong>protobuf</strong></li>
</ul>
<p>序列化数据非常简洁，紧凑，析速度非常快，提供了非常友好的动态库。使用简介，反序列化只需要一行代码。需要定义Message描述文件。但是在JavaBean和proto之间的转换较麻烦。</p>
<ul>
<li><strong>avro</strong></li>
</ul>
<p>Avro的产生解决了JSON的冗长和没有IDL的问题。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。</p>
<p>动态类型：Avro并不需要生成代码，模式和数据存放在一起，而模式使得整个数据的处理过程并不生成代码、静态数据类型等等。这方便了数据处理系统和语言的构造。<br>未标记的数据：由于读取数据的时候模式是已知的，那么需要和数据一起编码的类型信息就很少了，这样序列化的规模也就小了。<br>不需要用户指定字段号：即使模式改变，处理数据时新旧模式都是已知的，所以通过使用字段名称可以解决差异问题。</p>
<p>Reference：</p>
<p><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjr9bmYpbHOAhUXS2MKHZ-FBsMQFggcMAA&amp;url=http%3a%2f%2fwww%2ejavaworld%2ecom%2fcommunity%2fnode%2f2915&amp;usg=AFQjCNHoVbP6avcH8z2XE4COESBstSNv1g&amp;sig2=IxoKLEzlvMgqB3RhGwdRZQ&amp;bvm=bv.129391328,d.cGc&amp;cad=rja" target="_blank" rel="external">The Java serialization algorithm revealed</a><br><a href="http://luojinping.com/2016/01/03/Java%E5%BA%8F%E5%88%97%E5%8C%96/" target="_blank" rel="external">Zane blog</a><br><a href="http://www.infoq.com/cn/articles/serialization-and-deserialization" target="_blank" rel="external">序列化与反序列化</a></p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/java/">java</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/08/08/hexo/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">(Repo)hexo搭建博客</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2016/07/22/graduate/">
        <span class="next-text nav-default">graduate</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <div style="text-align:center;">
        <button class="btn" id="load-disqus" onclick="disqus.load();">加载 Disqus 评论</button>
    </div>
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2012 -
    
    2017
    <span class="footer-author">Xiaoyu Xue.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/henryhuang/hexo-theme-polarbearsimple">Polar Bear Simple</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    

<script type="text/javascript">
  var disqus_shortname = 'fredxue';
  var disqus_identifier = '2016/08/08/java-ser/';

  var disqus_title = "Java序列化";


  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
